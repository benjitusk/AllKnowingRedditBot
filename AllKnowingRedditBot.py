#!/usr/bin/python3
# ^ This line tells my computer to execute this file as python3
# Imports
import os   # For checking if this code is executing on the server or not
import praw  # This is the Reddit API library. See https://praw.readthedocs.io/en/latest for documentation
import time  # For timestamps in log messages and running tasks every x minutes
import random   # For generating random numbers. See !random trigger
import traceback    # For getting detailed logs if the bot crashes
# For getting passwords, API keys, and other authentication details from config.ini
import configparser
# This is our file, I moved a lot of 'dead end' functions there to declutter
import api
# import mysql.connector    # For connecting to the database. This is for an old feature that no longer exists.
from zalgo_text import zalgo    # For making cursed text. see !cursethis trigger
# This splits a string up into a ['list', 'of', 'words', 'like', 'this']
from nltk.tokenize import word_tokenize
# For getting an image from a URL. See image_from_url()
from semantic3.dates import DateService
from semantic3.units import ConversionService
from semantic3.solver import MathService

# Config and global variables
# These 2 lines are for getting persistant variables from config.ini (not on GitHub for obvious security reasons)
config = configparser.ConfigParser()
config.read('config.ini')

# The computer that this bot runs on all the time (I'm just gonna call it the server) has
# an 'environment variable' (its like a variable in python, but it's system-wide.) called 'PRODUCTION'.
# If an environment variable called 'PRODUCTION' exists and is set to True, then we know
# that this code is executing on the server. If this environment variable doesn't exist, then
# it means that this
if os.getenv('PRODUCTION'):
    DEBUG = False
else:
    # However, if this code is not executing on
    # If DEBUG is True, print debug info, only scan one subreddit, and force the script to crash on Exceptions
    DEBUG = True
# These are the persistant variables stored in config.ini:

# Keep track of how many times someone replies good/bad bot
good_bot_count = int(config['Bot Persistant Storage']['good_bot'])
bad_bot_count = int(config['Bot Persistant Storage']['bad_bot'])

# These keys provide authentication to prove that it's me when I query these respective web services
# I'm putting them into a {dict} just for organization
API_KEYS = {
    'GIPHY': config['Authentication']['GIPHY'],  # To get gifs
    'YOUTUBE': config['Authentication']['YOUTUBE'],  # To search YouTube
    'IBM': config['Authentication']['ibm translation'],  # To translate things
}
# Log in to Reddit using the akrb section in praw.ini, a file that contains reddit login info. NOT ON GITHUB
reddit = praw.Reddit("akrb")
# This forces the bot to conform to reddit's new standards when it comes to editing and submitting posts via the API
# Basically, it just shuts up the warning that happens when I don't use this.
reddit.validate_on_submit = True
# Debug settings...
if DEBUG:
    # If DEBUG, only moniter one subreddit to help create a controlled environment
    subreddit = 'testingground4bots'
    # Run background_tasks() every 30 seconds so we don't have to wait so long
    time_interval = 30
else:
    # Otherwise, operate as usual
    # and watch every subreddit EXCEPT r/testingground4bots
    # so as to not interfere with a possible alterante existing
    # debug session
    subreddit = 'all-testingground4bots'
    # And run background_tasks() only once every 2 minutes
    time_interval = 120


# The next bunch of lines is an extention to PRAW's reply function

# Move the original reply method to reply_core so we are not overwriting the reply function so we can still use it:
praw.reddit.Comment.reply_core = praw.reddit.Comment.reply

# Look into if there is a better way to do this...

# This is our own function that we are going to add to PRAW


def reply(self, message, type='REPLY'):  # self refers to the praw.reddit.Comment object
    # self_generated_replies is an array of comment_id's generated by comments that the bot made
    global self_generated_replies
    try:
        # Try to send a reply to Reddit using the original reply method
        c = self.reply_core(message)
    except Exception as exc:
        # If it doesn't work, well, let's look at the reason for that.
        if exc.__class__.__name__ == 'Forbidden':
            # If it's because we're banned
            # Print something to the console
            print(f'BANNED from r/{self.subreddit.display_name}\n')
            # And stop trying to reply to comments in this subreddit
            add_to_blacklist(self.subreddit.display_name)
        else:
            # If it's for some other reason, log it to the console for later examination
            print(f'Exception: {exc}\n')
        if DEBUG:
            # If we're debugging, crash on error
            raise
    else:
        # If no error occured, log the link to our comment to the console
        print(f'{type}: https://www.reddit.com{c.permalink}\n')
        # Add reply_id to self_generated_replies list
        self_generated_replies.append(c.id)


# Add extended_reply method to praw.reddit.Comment object
praw.reddit.Comment.reply = reply


# Find a way to implement this or phase it out!
# Get an instance of an authenticated MySQL session
# So I can store things in a data persistant method accessable anywhere on my computer (MySQL)
# mydb = mysql.connector.connect(
#     host=config['Authentication']['database host'],
#     user=config['Authentication']['database username'],
#     password=config['Authentication']['database password'],
#     database="reddit"
# )
# This allows us to re-use the cursor without being forced to read from it.
# Honestly, I don't 100% understand, but it works ¯\_(ツ)_/¯
# db = mydb.cursor(buffered=True)
# Initialize the table if it does not yet exist in this format:
# +-----------------+------------+
# | username (text) | value (int)|
# +-----------------+------------+
# | NormativeNomad  |          2 |
# | jperez81805     |         10 |
# | Matthew_Quigley |         13 |
# | Chuturmaat      |        149 |
# +-----------------+------------+
# db.execute('CREATE TABLE IF NOT EXISTS nicecount (username TEXT, value INTEGER)')


# This is sort of a stopwatch to keep track of when the last time we ran background_tasks()
background_tasks_stopwatch = time.time()

# Load blacklisted_subreddits to ignore
with open('blacklisted_subreddits.txt') as file:
    blacklisted_subreddits = file.read()
    blacklisted_subreddits = blacklisted_subreddits.split('\n')
    blacklisted_subreddits = list(filter(None, blacklisted_subreddits))

# Load blacklisted_users to ignore
with open('blacklisted_users.txt') as file:
    blacklisted_users = file.read()
    blacklisted_users = blacklisted_users.split('\n')
    blacklisted_users = list(filter(None, blacklisted_users))

# We don't need to load self_generated_replies from previous runs,
# because we are only watching the live comment stream
self_generated_replies = []

# Print the starting paramaters to the console
print(f'''Initializing bot with the following paramaters:
DEBUG: {DEBUG}
Subreddit: {subreddit}
good_bot_count: {good_bot_count}
bad_bot_count: {bad_bot_count}
Reddit Login: {reddit.user.me().name}
Scanned 0 comments...''')


# Allows us to modify any blacklist without stopping and restarting the script
# Basically it appends the username/subreddit to the blacklist array[], and adds it to the file for persistant storage
# If list isn't specified, assume 'subreddit'
def add_to_blacklist(value, list='subreddit'):
    if list == 'user':
        # set the filename
        blacklist = 'blacklisted_users.txt'
        # append to blacklisted_users[]
        blacklisted_users.append(value)
    if list == 'subreddit':
        # set the filename
        blacklist = 'blacklisted_subreddits.txt'
        # append to blacklisted_subreddits[]
        blacklisted_subreddits.append(value)
    with open(blacklist, 'a') as file:  # open the specified files
        file.write(f'{value}\n')  # add `value` to the end


# This function runs whenever the background_tasks_stopwatch timestamp
# is greater than 30 or 120 seconds ago, depending on the debugging mode.
def background_tasks():
    # Delete comments with a score of -1 or lower
    delete_negative_comments()
    # Check Reddit Inbox for messages to reply to
    interact_with_replies()
    # Save the niceount, good and bad bot count to persistant storage
    save_variables()


# Delete my comments that are being downvoted to avoid karma loss
def delete_negative_comments():
    # Get the last comments I made (max 1000 comments) sorted by date commented
    for c in reddit.user.me().comments.new():
        # Check the karma of that specific comment
        if c.score <= -1:
            # delete if -1 or less
            c.delete()


def interact_with_replies():
    global good_bot_count
    global bad_bot_count
    for comment in reddit.inbox.unread():
        if comment.was_comment:
            if comment.body.lower() == '!blacklist subreddit':
                comment.mark_read()
                if comment.author in comment.subreddit.moderator() or comment.author in ['generic_reddit_bot_2', 'benjixinator']:
                    with open('blacklisted_subreddits.txt', 'a') as blacklist:
                        blacklist.write(f'{comment.subreddit.display_name}')
                    reply(
                        comment, 'This subreddit has now been added to the blacklist. If you want to un-blacklist this subreddit, DM u/benjixinator with the name of the subreddit.', f'ADDED r/{comment.subreddit.display_name} TO THE SUBREDDIT BLACKLIST')
                else:
                    reply(
                        comment, f'Sorry {comment.author.name}, you need to be the moderator of r/{comment.subreddit.display_name} to add this subreddit to the blacklist. However, I have added your account to the user blacklist. To undo this action, pm u/benjixinator.', f'ADDED u/{comment.author.name} TO THE USER BLACKLIST')
                    with open('blacklisted_users.txt', 'a') as blacklist:
                        blacklist.write(f'{comment.author.name}\n')
            if comment.body.lower() == '!blacklist':
                comment.mark_read()
                with open('blacklisted_users.txt', 'a') as blacklist:
                    blacklist.write(f'{comment.author.name}\n')
                comment.reply(f'Your username, `{comment.author.name}`, has been added to the user blacklist. To undo this action, pm u/benjixinator.',
                              f'ADDED u/{comment.author.name} TO THE USER BLACKLIST')
            if comment.body.lower() == '!delete':
                comment.mark_read()
                parent = comment.parent()
                if comment.author.name == parent.parent().author.name or comment.author in comment.subreddit.moderator() or comment.author.name == 'benjixinator':
                    try:
                        parent.edit(
                            f'u/{comment.author.name} has requested this comment be **deleted**.')
                        print('Deleted a comment\n')
                    except:
                        comment.author.message(
                            '!delete', f'I tried to delete [this comment](https://www.reddit.com{parent.permalink}), but an error occured. If it is urgent that the comment gets deleted, please DM u/benjixinator. I\'m sorry for the inconvenience.')
                        print(
                            f'Could not delete this comment: https://www.reddit.com{parent.permalink}\n')
                        if DEBUG:
                            raise
                else:
                    reply(
                        comment, f'Sorry, only u/{comment.author.name} or a moderator can `!delete` this comment.',)
            if 'good bot' in comment.body.lower():
                comment.mark_read()
                good_bot_count += 1
                try:
                    comment.upvote()
                    reply(comment,
                          f'Thank you, {comment.author.name}!\n\nThe current rating is {good_bot_count} : {bad_bot_count} with a {round(good_bot_count/(bad_bot_count+good_bot_count)*100)}% approval rate.', 'RATING')
                except Exception as e:
                    print(f'Exception: {e}\n')
                    if DEBUG:
                        raise
            if 'bad bot' in comment.body.lower():
                comment.mark_read()
                bad_bot_count += 1
                try:
                    comment.downvote()
                    reply(comment,
                          f'I\'m sorry you feel that way.\n\nThe current rating is {good_bot_count} : {bad_bot_count} with a {round(good_bot_count/(bad_bot_count+good_bot_count)*100)}% approval rate.', 'RATING')
                except Exception as e:
                    print(f'Exception: {e}\n')
                    if DEBUG:
                        raise


def log(data):
    print(data)
    write_to_log(data)


def main():
    try:
        global good_bot_count
        global bad_bot_count
        global blacklisted_subreddits
        global blacklisted_users
        global background_tasks_stopwatch
        comment_count = 0
        # If we are debugging, we are only watching one subreddit, with a lower traffic. to avoid repeat traffic, skip_existing = true only if debugging
        for comment in reddit.subreddit(subreddit).stream.comments(pause_after=0, skip_existing=DEBUG):
            if time.time() - background_tasks_stopwatch > time_interval:  # Every 2 minutes
                if DEBUG:
                    print('Running background_tasks()\n')
                background_tasks()
                background_tasks_stopwatch = time.time()
            if comment == None or comment.author == None:
                continue
            comment_count += 1
            if comment.author.name in blacklisted_users:
                if DEBUG:
                    print(f'Blacklist: u/{comment.author.name}\n')
                continue
            if comment.subreddit.display_name in blacklisted_subreddits:
                if DEBUG:
                    print(f'Blacklist: r/{comment.subreddit.display_name}\n')
                continue
            if '>!' in comment.body and '!<' in comment.body:
                continue
            if not DEBUG:
                api.delete_last_line()
            print(f'Scanned {comment_count} comments...')
            process_comments(comment)
    except KeyboardInterrupt:
        print('\nKeyboardInterrupt: Cleaning up...')
        background_tasks()
        # try:
        # mydb.commit()
        # except Exception:  # Hmm, seems like the DB timed out.
        # pass
        # mydb.close()
        print('Bye!')
        return
    except Exception as e:
        log(e)
        log(traceback.format_exc())
        if DEBUG:
            raise
        else:
            main()


def process_comments(comment):
    global blacklisted_subreddits
    global blacklisted_users
    global self_generated_replies
    global comment_count
    if comment is None or comment.stickied or comment.distinguished:
        return
    if comment.id in self_generated_replies:
        return
    if comment.subreddit.display_name in blacklisted_subreddits:
        return
    if comment.author.name in blacklisted_users:
        return
    body = comment.body.lower()

    # ADVICE
    if '!advice' in body:
        comment.reply(api.get_advice(), 'ADVICE')

    # ZALGO
    if '!cursethis' in body:
        # Step 1: Get the parent object
        parent = comment.parent()

        # Step 2: get content of parent
        try:
            text = parent.body
        except AttributeError:
            try:
                text = parent.selftext
            except AttributeError:
                return

        # Step 3: Zalgo-ify repeatedly
        for _ in range(3):
            text = zalgo.zalgo().zalgofy(text)

        # Step 4: Reply
        comment.reply(f'{text}{api.get_footer()}', 'ZALGO')

    # DADJOKE
    if '!dadjoke' in body:
        comment.reply(api.get_dadjoke(), 'DADJOKE')

    # DEFINE
    if '!define' in body:
        arguments = api.get_arguments('!define', body)
        if arguments == False:
            arguments = 'null'
        word = word_tokenize(arguments)[0]
        definition = api.get_definition(word)
        comment.reply(definition, 'DEFINITION')

    # FEATURES
    if '!features' in body:
        features = '''
Key: <mandatory arguments>, [optional arguments], (option A) | (option B)

# Current features:

* !gif [search term]

* !lyrics (<title> [by <artist>]) | (<snippet of lyrics>)

* !define <word>

* !youtube <search term> [# <number of results>]

* !joke

* !snapple

* !random

* !cursethis

* !advice

* !insult
---

# Upcoming features:

* Wikipedia Search

* Send a feature request to the developer

* Random quote'''
        comment.reply(features, 'FEATURES')

    # GIF
    if '!gif' in body:
        arguments = api.get_arguments('!gif', body)
        gif = api.get_gif(arguments)
        comment.reply(gif, 'GIF')

    # INSULT
    if '!insult' in body:
        comment.reply(api.get_insult(), 'INSULT')

    # JOKE
    if '!joke' in body:
        comment.reply(api.get_joke(), 'JOKE')

    # LYRICS
    if '!lyrics' in body:
        lyrics = api.get_lyrics(body)
        comment.reply(lyrics, 'LYRICS')

    # RANDOM
    if '!random' in body:
        reply(
            comment, f'Your very own random number between 1 and 1,000 is `{random.randint(1, 1000)}`', 'RANDOM')

    # SNAPPLE
    if '!snapple' in body:
        comment.reply(api.get_random_fact(), 'SNAPPLE')

    # TRANSCRIBE
    if '!transcribe' in body:
        image_transcription = api.transcribe_image(comment)
        comment.reply(image_transcription, 'TRANSCRIBE')

    # Translate
    if '!translate' in body:
        comment.reply(api.get_translation(comment), 'TRANSLATE')

    # YOUTUBE
    if '!youtube' in body:
        query = api.get_arguments('!youtube', body)
        youtube = api.search_youtube(query)
        comment.reply(youtube, 'YOUTUBE')


# def reply(comment, message, type='REPLY'):
#     # Make sure not to exclude comments that were automatically generated...
#     global self_generated_replies
#     try:
#         c = comment.reply(message)
#     except Exception as e:
#         if e.__class__.__name__ == 'Forbidden':
#             print(f'BANNED from r/{comment.subreddit.display_name}\n')
#             add_to_blacklist(f'{comment.subreddit.display_name}')
#         else:
#             print(f'Exception: {e}\n')
#         if DEBUG:
#             raise
#     else:
#         print(f'{type}: https://www.reddit.com{c.permalink}\n')
#         # Add reply to self_generated_replies list
#         self_generated_replies.append(c.id)
#         with open('self_generated_replies.txt', 'a') as agr:
#             agr.write(f'{c.id}\n')


def save_variables():
    global good_bot_count
    global bad_bot_count
    config['Bot Persistant Storage']['good_bot'] = str(good_bot_count)
    config['Bot Persistant Storage']['bad_bot'] = str(bad_bot_count)
    with open('config.ini', 'w') as configfile:
        config.write(configfile)


def write_to_log(data):
    with open('bot.log', 'a') as log_file:
        log_file.write(f'[{time.ctime()}]:\t{data}\n')


if __name__ == "__main__":
    main()
